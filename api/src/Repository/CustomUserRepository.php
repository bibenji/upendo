<?php

namespace Upendo\Repository;

use Doctrine\ORM\EntityRepository;
use Upendo\Entity\Profile;
use Upendo\Entity\User;

/**
 * ProfileRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class CustomUserRepository extends EntityRepository
{
    public function getPossibleDailyProfiles(User $user)
    {
        $qb = $this->createQueryBuilder('u');

        $nots = $qb
            ->leftJoin('u.dailyProfileAsOne', 'dpao')
            ->leftJoin('u.dailyProfileAsTwo', 'dpat')
            ->where('dpao.userOne = :current_user')
            ->andWhere('dpao.userTwo = :other_user')
            ->andWhere('dpat.userOne = :other_user')
            ->andWhere('dpat.userTwo = :current_user')
            ->setParameters([
                'current_user' => $user,
                'other_user' => 'u'
            ])
            ->getQuery()
            ->execute()
        ;

        $qb = $this->createQueryBuilder('u');

        $qb
            ->leftJoin('u.profile', 'p')
            ->leftJoin('u.relationsAsOne', 'rao')
            ->leftJoin('u.relationsAsTwo', 'rat')
//            ->innerJoin('p.user', 'o') // sinon doctrine rajoute des alias improbables... ??? @fixme
        ;

        if ($searchingGender = $user->getProfile()->getSearchingGender()) {
            if ($searchingGender !== Profile::SEARCHING_BOTH) {
                $qb
                    ->andWhere('u.gender = :gender')
                    ->setParameter('gender', $searchingGender)
                ;
            }
        }

        if ($user->getProfile()->getSearchingAgeMin()) {
            $now = new \DateTime();
            $intervalMin = new \DateInterval('P' . $user->getProfile()->getSearchingAgeMin() . 'Y');
            $minBirthdate = $now->sub($intervalMin);

            $qb
                ->andWhere('p.birthdate <= :minBirthdate')
                ->setParameter('minBirthdate', $minBirthdate)
            ;
        }

        if ($user->getProfile()->getSearchingAgeMax()) {
            $now = new \DateTime();
            $intervalMax = new \DateInterval('P' . $user->getProfile()->getSearchingAgeMax() . 'Y');
            $maxBirthdate = $now->sub($intervalMax);

            $qb
                ->andWhere('p.birthdate >= :maxBirthdate')
                ->setParameter('maxBirthdate', $maxBirthdate)
            ;
        }

        $qb
            ->andWhere($qb->expr()->orX(
                // soit rao a un status like et l'utilisateur courant n'est pas le dernier a avoir liké
                $qb->expr()->andX(
                    $qb->expr()->eq('rao.status', ':likedStatus'),
                    $qb->expr()->neq('rao.lastActionUserId', ':lastActionUserId')
                ),
                // soit rat a un status like et l'utilisateur courant n'est pas le dernier a avoir liké
                $qb->expr()->andX(
                    $qb->expr()->eq('rat.status', ':likedStatus'),
                    $qb->expr()->neq('rat.lastActionUserId', ':lastActionUserId')
                ),
                // soit ni rao ni rat n'a encore été défini
                $qb->expr()->andX(
                    $qb->expr()->isNull('rao.status'),
                    $qb->expr()->isNull('rat.status')
                )
            ))
            ->setParameter('likedStatus', "1")
            ->setParameter('lastActionUserId', $user->getId())
        ;

        if (count($nots) > 0) {
            $qb
                ->andWhere(
                    $qb->expr()->notIn('u.id', $nots)
                )
            ;
        }

        return $qb->getQuery()->execute();
    }
}
